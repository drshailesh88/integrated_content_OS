"""
Slack Sender Module
Sends notifications to Slack channel.
"""

import requests
from datetime import datetime
from typing import Dict, List, Optional
import sys
sys.path.insert(0, '..')
from config import SLACK_BOT_TOKEN, SLACK_CHANNEL, REQUEST_TIMEOUT


def send_slack_message(
    text: str,
    blocks: List[Dict] = None,
    channel: str = None
) -> bool:
    """
    Send a message to Slack.
    
    Args:
        text: Plain text message (fallback)
        blocks: Optional Block Kit blocks for rich formatting
        channel: Channel ID (uses config default if not provided)
        
    Returns:
        True if sent successfully
    """
    if not SLACK_BOT_TOKEN:
        print("  âš  SLACK_BOT_TOKEN not set - skipping Slack")
        return False
    
    channel = channel or SLACK_CHANNEL
    if not channel:
        print("  âš  SLACK_CHANNEL not set - skipping Slack")
        return False
    
    try:
        payload = {
            "channel": channel,
            "text": text
        }
        if blocks:
            payload["blocks"] = blocks
        
        response = requests.post(
            "https://slack.com/api/chat.postMessage",
            headers={
                "Authorization": f"Bearer {SLACK_BOT_TOKEN}",
                "Content-Type": "application/json"
            },
            json=payload,
            timeout=REQUEST_TIMEOUT
        )
        response.raise_for_status()
        data = response.json()
        
        if data.get("ok"):
            print(f"  âœ“ Slack message sent")
            return True
        else:
            print(f"  âœ— Slack error: {data.get('error', 'Unknown error')}")
            return False
            
    except Exception as e:
        print(f"  âœ— Slack error: {e}")
        return False


def build_digest_blocks(
    b2c_count: int,
    b2b_count: int,
    b2c_titles: List[str] = None,
    b2b_titles: List[str] = None
) -> List[Dict]:
    """
    Build Slack Block Kit blocks for the digest notification.
    
    Args:
        b2c_count: Number of B2C articles
        b2b_count: Number of B2B articles
        b2c_titles: Optional list of B2C article titles
        b2b_titles: Optional list of B2B article titles
        
    Returns:
        List of Block Kit block dictionaries
    """
    date_str = datetime.now().strftime('%B %d, %Y')
    
    blocks = [
        {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": "ðŸ“¬ Medical Insights Digest Ready",
                "emoji": True
            }
        },
        {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*{date_str}*\n\nYour daily medical content digest has been generated and sent to your email."
            }
        },
        {
            "type": "divider"
        },
        {
            "type": "section",
            "fields": [
                {
                    "type": "mrkdwn",
                    "text": f"*ðŸ“¢ Public Articles*\n{b2c_count} pieces"
                },
                {
                    "type": "mrkdwn",
                    "text": f"*ðŸ‘¨â€âš•ï¸ Clinical Editorials*\n{b2b_count} pieces"
                }
            ]
        }
    ]
    
    # Add B2C titles if provided
    if b2c_titles and len(b2c_titles) > 0:
        titles_text = "\n".join(f"â€¢ {t[:60]}..." if len(t) > 60 else f"â€¢ {t}" for t in b2c_titles[:3])
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*B2C Topics:*\n{titles_text}"
            }
        })
    
    # Add B2B titles if provided
    if b2b_titles and len(b2b_titles) > 0:
        titles_text = "\n".join(f"â€¢ {t[:60]}..." if len(t) > 60 else f"â€¢ {t}" for t in b2b_titles[:3])
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*B2B Topics:*\n{titles_text}"
            }
        })
    
    blocks.append({
        "type": "divider"
    })
    
    blocks.append({
        "type": "context",
        "elements": [
            {
                "type": "mrkdwn",
                "text": "ðŸ¤– Generated by Medical Content Engine"
            }
        ]
    })
    
    return blocks


def send_digest_notification(triaged_articles: Dict[str, list]) -> bool:
    """
    Send a Slack notification about the digest.
    
    Args:
        triaged_articles: Dictionary with 'b2c', 'b2b' article lists
        
    Returns:
        True if sent successfully
    """
    print(f"\nðŸ’¬ Sending Slack notification...")
    print("-" * 40)
    
    b2c_articles = triaged_articles.get('b2c', [])
    b2b_articles = triaged_articles.get('b2b', [])
    
    # Count and get titles
    b2c_with_content = [a for a in b2c_articles if a.get('generated_content')]
    b2b_with_content = [a for a in b2b_articles if a.get('generated_content')]
    
    b2c_count = len(b2c_with_content)
    b2b_count = len(b2b_with_content)
    
    if b2c_count == 0 and b2b_count == 0:
        print("  â—‹ No articles to notify about")
        return False
    
    b2c_titles = [a.get('title', '') for a in b2c_with_content]
    b2b_titles = [a.get('title', '') for a in b2b_with_content]
    
    # Build message
    text = f"ðŸ“¬ Medical Insights Digest: {b2c_count} public + {b2b_count} clinical articles ready"
    blocks = build_digest_blocks(b2c_count, b2b_count, b2c_titles, b2b_titles)
    
    # Send
    result = send_slack_message(text, blocks)
    
    print("-" * 40)
    return result


if __name__ == "__main__":
    # Test with sample data
    test_articles = {
        'b2c': [
            {'title': 'Mediterranean Diet Shows 30% Reduction in CV Events', 'generated_content': 'content'},
            {'title': 'Sleep Duration Linked to Heart Health', 'generated_content': 'content'}
        ],
        'b2b': [
            {'title': 'FFR-Guided PCI: 5-Year Follow-Up Results', 'generated_content': 'content'}
        ]
    }
    
    send_digest_notification(test_articles)
